<?php
/**
 * @file
 * Code for the Farm Sensor Listener module.
 */

/**
 * Implements hook_menu().
 */
function farm_sensor_listener_menu() {
  $items = array();
  $items['farm/sensor/listener/%'] = array(
    'page callback' => 'farm_sensor_listener_page_callback',
    'page arguments' => array(3),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_entity_delete().
 */
function farm_sensor_listener_entity_delete($entity, $type) {

  // Only act on farm asset entities.
  if ($type != 'farm_asset') {
    return;
  }

  // Only act on sensor assets.
  if ($entity->type != 'sensor') {
    return;
  }

  // Only act on "listener" type sensors.
  if ($entity->sensor_type != 'listener') {
    return;
  }

  // Delete data from the {farm_sensor_data} table.
  db_delete('farm_sensor_data')->condition('id', $entity->id)->execute();
}

/**
 * Callback function for receiving JSON over HTTP and storing data to the {farm_sensor_data} table.
 *
 * @param $public_key
 *   The public key of the sensor that is pushing the data.
 *
 * JSON should be in the following format:
 *   {
 *     "timestamp": 1234567890,
 *     "sensor1": 76.5,
 *     "sensor2": 55,
 *   }
 * Where:
 *   "timestamp" is an optional Unix timestamp of the sensor reading. If it's
 *     omitted, the time that the request is received will be used instead.
 *   The rest of the JSON properties will be considered sensor readings, and
 *   should be in the form "[name]": [value]. The value should be a decimal or
 *   integer, and will be stored as a fraction (numerator and denominator) in
 *   the database, for accurate precision.
 *
 * @return int
 *   Returns MENU_FOUND or MENU_NOT_FOUND.
 */
function farm_sensor_listener_page_callback($public_key) {

  // Load the private key from the URL query string.
  $params = drupal_get_query_parameters();

  // If the private key is not set, bail.
  if (empty($params['private_key'])) {
    return MENU_FOUND;
  }

  // Load the private key.
  $private_key = $params['private_key'];

  // Look up the sensor by it's public key.
  $sensor = farm_sensor_listener_load($public_key);

  // If no asset was found, bail.
  if (empty($sensor)) {
    return MENU_NOT_FOUND;
  }

  // Compare the private key.
  if ($sensor->sensor_settings['private_key'] != $private_key) {
    return MENU_FOUND;
  }

  // Pull the data from the request.
  $data = drupal_json_decode(file_get_contents("php://input"));

  // If the data is empty, bail.
  if (empty($data)) {
    return MENU_FOUND;
  }

  // Generate a timestamp from the request time. This will be overridden if
  // a timestamp is provided in the JSON.
  $timestamp = REQUEST_TIME;
  if (!empty($data['timestamp'])) {
    $timestamp = $data['timestamp'];
  }

  // Iterate over the JSON properties.
  foreach ($data as $key => $value) {

    // If the key is "timestamp", skip to the next property in the JSON.
    if ($key == 'timestamp') {
      continue;
    }

    // If the value is not numeric, skip it.
    if (!is_numeric($value)) {
      continue;
    }

    // Create a row to store in the database;
    $row = array(
      'id' => $sensor->id,
      'timestamp' => $timestamp,
      'name' => $key,
    );

    // Convert the value to a fraction.
    $fraction = fraction_from_decimal($value);
    $row['value_numerator'] = $fraction->getNumerator();
    $row['value_denominator'] = $fraction->getDenominator();

    // Enter the reading into the {farm_sensor_data} table.
    drupal_write_record('farm_sensor_data', $row);
  }

  // Return found.
  return MENU_FOUND;
}

/**
 * Implements hook_farm_sensor_type_info().
 */
function farm_sensor_listener_farm_sensor_type_info() {
  return array(
    'listener' => array(
      'label' => t('Listener'),
      'description' => t('Open up a data listener that accepts data from
      external sources over HTTP'),
      'form' => 'farm_sensor_listener_settings_form',
    ),
  );
}

/**
 * Settings form for listener sensor.
 *
 * @param array $settings
 *   The farm sensor settings.
 *
 * @return array
 *   Returns a form with settings for this  Listener sensor.
 */
function farm_sensor_listener_settings_form($settings = array()) {

  // If a public/private key haven't been set yet, generate them.
  if (empty($settings['public_key'])) {
    $settings['public_key'] = hash('md5', mt_rand());
  }
  if (empty($settings['private_key'])) {
    $settings['private_key'] = hash('md5', mt_rand());
  }

  // Automatically generated public key.
  $form['public_key'] = array(
    '#type' => 'textfield',
    '#title' => t('Public key'),
    '#description' => t('An automatically generated public key for this sensor.'),
    '#default_value' => $settings['public_key'],
  );

  // Automatically generated private key.
  $form['private_key'] = array(
    '#type' => 'textfield',
    '#title' => t('Private key'),
    '#description' => t('An automatically generated private key for this sensor.'),
    '#default_value' => $settings['private_key'],
  );

  return $form;
}

/**
 * Implements hook_views_api().
 */
function farm_sensor_listener_views_api() {
  return array('api' => 3);
}

/**
 * Helper function for loading a sensor asset from it's public/private key.
 *
 * @param $key
 *   The sensor public/private key.
 *
 * @return FarmAsset|bool
 *   Returns a farm sensor asset, or FALSE if not found.
 */
function farm_sensor_listener_load($key) {

  // Query the {farm_sensor} table to look for a sensor with a matching key.
  $sql = 'SELECT id FROM {farm_sensor} WHERE settings LIKE :settings';
  $result = db_query($sql, array(':settings' => '%' . db_like($key) . '%'));
  $asset_id = $result->fetchField();

  // If no asset id was found, bail.
  if (empty($asset_id)) {
    return FALSE;
  }

  // Attempt to load the sensor asset.
  $asset = farm_asset_load($asset_id);

  // If a sensor wasn't loaded, bail.
  if (empty($asset)) {
    return FALSE;
  }

  // Return the sensor asset.
  return $asset;
}

/**
 * Implements hook_farm_asset_view_views().
 */
function farm_sensor_listener_farm_asset_view_views($farm_asset) {

  // If the entity is not a sensor, bail.
  if ($farm_asset->type != 'sensor') {
    return array();
  }

  // If the sensor is not a listener, bail.
  if ($farm_asset->sensor_type != 'listener') {
    return array();
  }

  // Return a list of Views to include on listener sensors.
  return array(
    'farm_sensor_data',
  );
}
